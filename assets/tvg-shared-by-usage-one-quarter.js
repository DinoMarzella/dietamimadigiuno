"use strict";(self["webpackChunktvg_shopify_theme"]=self["webpackChunktvg_shopify_theme"]||[]).push([[667],{570:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{
getCartMachine:()=>getCartMachine});var lib=__webpack_require__(643);class HTTPError extends Error{constructor(response,request,options){const code=response.status||0===response.status?response.status:"";const title=response.statusText||""
;const status=`${code} ${title}`.trim();const reason=status?`status code ${status}`:"an unknown error";super(`Request failed with ${reason}`);Object.defineProperty(this,"response",{enumerable:true,configurable:true,writable:true,
value:void 0});Object.defineProperty(this,"request",{enumerable:true,configurable:true,writable:true,value:void 0});Object.defineProperty(this,"options",{enumerable:true,configurable:true,writable:true,value:void 0});this.name="HTTPError"
;this.response=response;this.request=request;this.options=options}}class TimeoutError extends Error{constructor(request){super("Request timed out");Object.defineProperty(this,"request",{enumerable:true,configurable:true,writable:true,
value:void 0});this.name="TimeoutError";this.request=request}}const isObject=value=>null!==value&&"object"===typeof value;const validateAndMerge=function(){
for(var _len=arguments.length,sources=new Array(_len),_key=0;_key<_len;_key++)sources[_key]=arguments[_key]
;for(const source of sources)if((!isObject(source)||Array.isArray(source))&&"undefined"!==typeof source)throw new TypeError("The `options` argument must be an object");return deepMerge({},...sources)};const mergeHeaders=function(){
let source1=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},source2=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const result=new globalThis.Headers(source1)
;const isHeadersInstance=source2 instanceof globalThis.Headers;const source=new globalThis.Headers(source2)
;for(const[key,value]of source.entries())if(isHeadersInstance&&"undefined"===value||void 0===value)result.delete(key);else result.set(key,value);return result};const deepMerge=function(){
for(var _len=arguments.length,sources=new Array(_len),_key=0;_key<_len;_key++)sources[_key]=arguments[_key];let returnValue={};let headers={};for(const source of sources)if(Array.isArray(source)){
if(!Array.isArray(returnValue))returnValue=[];returnValue=[...returnValue,...source]}else if(isObject(source)){for(let[key,value]of Object.entries(source)){if(isObject(value)&&key in returnValue)value=deepMerge(returnValue[key],value)
;returnValue={...returnValue,[key]:value}}if(isObject(source.headers)){headers=mergeHeaders(headers,source.headers);returnValue.headers=headers}}return returnValue};const supportsRequestStreams=(()=>{let duplexAccessed=false
;let hasContentType=false;const supportsReadableStream="function"===typeof globalThis.ReadableStream;if(supportsReadableStream)hasContentType=new globalThis.Request("https://a.com",{body:new globalThis.ReadableStream,method:"POST",
get duplex(){duplexAccessed=true;return"half"}}).headers.has("Content-Type");return duplexAccessed&&!hasContentType})();const supportsAbortController="function"===typeof globalThis.AbortController
;const supportsResponseStreams="function"===typeof globalThis.ReadableStream;const supportsFormData="function"===typeof globalThis.FormData;const requestMethods=["get","post","put","patch","head","delete"];const validate=()=>{};validate()
;const responseTypes={json:"application/json",text:"text/*",formData:"multipart/form-data",arrayBuffer:"*/*",blob:"*/*"};const maxSafeTimeout=2147483647;const stop=Symbol("stop")
;const normalizeRequestMethod=input=>requestMethods.includes(input)?input.toUpperCase():input;const retryMethods=["get","put","head","delete","options","trace"];const retryStatusCodes=[408,413,429,500,502,503,504]
;const retryAfterStatusCodes=[413,429,503];const defaultRetryOptions={limit:2,methods:retryMethods,statusCodes:retryStatusCodes,afterStatusCodes:retryAfterStatusCodes,maxRetryAfter:Number.POSITIVE_INFINITY,
backoffLimit:Number.POSITIVE_INFINITY};const normalizeRetryOptions=function(){let retry=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("number"===typeof retry)return{...defaultRetryOptions,limit:retry}
;if(retry.methods&&!Array.isArray(retry.methods))throw new Error("retry.methods must be an array");if(retry.statusCodes&&!Array.isArray(retry.statusCodes))throw new Error("retry.statusCodes must be an array");return{...defaultRetryOptions,
...retry,afterStatusCodes:retryAfterStatusCodes}};async function timeout(request,abortController,options){return new Promise(((resolve,reject)=>{const timeoutId=setTimeout((()=>{if(abortController)abortController.abort()
;reject(new TimeoutError(request))}),options.timeout);void options.fetch(request).then(resolve).catch(reject).then((()=>{clearTimeout(timeoutId)}))}))}const isDomExceptionSupported=Boolean(globalThis.DOMException)
;function composeAbortError(signal){if(isDomExceptionSupported)return new DOMException(signal?.reason??"The operation was aborted.","AbortError");const error=new Error(signal?.reason??"The operation was aborted.");error.name="AbortError"
;return error}async function delay(ms,param){let{signal:signal}=param;return new Promise(((resolve,reject)=>{if(signal){if(signal.aborted){reject(composeAbortError(signal));return}signal.addEventListener("abort",handleAbort,{once:true})}
function handleAbort(){reject(composeAbortError(signal));clearTimeout(timeoutId)}const timeoutId=setTimeout((()=>{signal?.removeEventListener("abort",handleAbort);resolve()}),ms)}))}class Ky{static create(input,options){
const ky=new Ky(input,options);const fn=async()=>{if(ky._options.timeout>maxSafeTimeout)throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);await Promise.resolve();let response=await ky._fetch()
;for(const hook of ky._options.hooks.afterResponse){const modifiedResponse=await hook(ky.request,ky._options,ky._decorateResponse(response.clone()));if(modifiedResponse instanceof globalThis.Response)response=modifiedResponse}
ky._decorateResponse(response);if(!response.ok&&ky._options.throwHttpErrors){let error=new HTTPError(response,ky.request,ky._options);for(const hook of ky._options.hooks.beforeError)error=await hook(error);throw error}
if(ky._options.onDownloadProgress){if("function"!==typeof ky._options.onDownloadProgress)throw new TypeError("The `onDownloadProgress` option must be a function")
;if(!supportsResponseStreams)throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");return ky._stream(response.clone(),ky._options.onDownloadProgress)}return response}
;const isRetriableMethod=ky._options.retry.methods.includes(ky.request.method.toLowerCase());const result=isRetriableMethod?ky._retry(fn):fn();for(const[type,mimeType]of Object.entries(responseTypes))result[type]=async()=>{
ky.request.headers.set("accept",ky.request.headers.get("accept")||mimeType);const awaitedResult=await result;const response=awaitedResult.clone();if("json"===type){if(204===response.status)return""
;const arrayBuffer=await response.clone().arrayBuffer();const responseSize=arrayBuffer.byteLength;if(0===responseSize)return"";if(options.parseJson)return options.parseJson(await response.text())}return response[type]()};return result}
_calculateRetryDelay(error){this._retryCount++;if(this._retryCount<this._options.retry.limit&&!(error instanceof TimeoutError)){if(error instanceof HTTPError){if(!this._options.retry.statusCodes.includes(error.response.status))return 0
;const retryAfter=error.response.headers.get("Retry-After");if(retryAfter&&this._options.retry.afterStatusCodes.includes(error.response.status)){let after=Number(retryAfter)
;if(Number.isNaN(after))after=Date.parse(retryAfter)-Date.now();else after*=1e3;if("undefined"!==typeof this._options.retry.maxRetryAfter&&after>this._options.retry.maxRetryAfter)return 0;return after}if(413===error.response.status)return 0
}const BACKOFF_FACTOR=.3;return Math.min(this._options.retry.backoffLimit,BACKOFF_FACTOR*2**(this._retryCount-1)*1e3)}return 0}_decorateResponse(response){
if(this._options.parseJson)response.json=async()=>this._options.parseJson(await response.text());return response}async _retry(fn){try{return await fn()}catch(error){const ms=Math.min(this._calculateRetryDelay(error),maxSafeTimeout)
;if(0!==ms&&this._retryCount>0){await delay(ms,{signal:this._options.signal});for(const hook of this._options.hooks.beforeRetry){const hookResult=await hook({request:this.request,options:this._options,error:error,retryCount:this._retryCount
});if(hookResult===stop)return}return this._retry(fn)}throw error}}async _fetch(){for(const hook of this._options.hooks.beforeRequest){const result=await hook(this.request,this._options);if(result instanceof Request){this.request=result
;break}if(result instanceof Response)return result}if(false===this._options.timeout)return this._options.fetch(this.request.clone());return timeout(this.request.clone(),this.abortController,this._options)}
_stream(response,onDownloadProgress){const totalBytes=Number(response.headers.get("content-length"))||0;let transferredBytes=0;if(204===response.status){if(onDownloadProgress)onDownloadProgress({percent:1,totalBytes:totalBytes,
transferredBytes:transferredBytes},new Uint8Array);return new globalThis.Response(null,{status:response.status,statusText:response.statusText,headers:response.headers})}return new globalThis.Response(new globalThis.ReadableStream({
async start(controller){const reader=response.body.getReader();if(onDownloadProgress)onDownloadProgress({percent:0,transferredBytes:0,totalBytes:totalBytes},new Uint8Array);async function read(){
const{done:done,value:value}=await reader.read();if(done){controller.close();return}if(onDownloadProgress){transferredBytes+=value.byteLength;const percent=0===totalBytes?0:transferredBytes/totalBytes;onDownloadProgress({percent:percent,
transferredBytes:transferredBytes,totalBytes:totalBytes},value)}controller.enqueue(value);await read()}await read()}}),{status:response.status,statusText:response.statusText,headers:response.headers})}constructor(input,options={}){
Object.defineProperty(this,"request",{enumerable:true,configurable:true,writable:true,value:void 0});Object.defineProperty(this,"abortController",{enumerable:true,configurable:true,writable:true,value:void 0})
;Object.defineProperty(this,"_retryCount",{enumerable:true,configurable:true,writable:true,value:0});Object.defineProperty(this,"_input",{enumerable:true,configurable:true,writable:true,value:void 0});Object.defineProperty(this,"_options",{
enumerable:true,configurable:true,writable:true,value:void 0});this._input=input;this._options={credentials:this._input.credentials||"same-origin",...options,headers:mergeHeaders(this._input.headers,options.headers),hooks:deepMerge({
beforeRequest:[],beforeRetry:[],beforeError:[],afterResponse:[]},options.hooks),method:normalizeRequestMethod(options.method??this._input.method),prefixUrl:String(options.prefixUrl||""),retry:normalizeRetryOptions(options.retry),
throwHttpErrors:false!==options.throwHttpErrors,timeout:"undefined"===typeof options.timeout?1e4:options.timeout,fetch:options.fetch??globalThis.fetch.bind(globalThis)}
;if("string"!==typeof this._input&&!(this._input instanceof URL||this._input instanceof globalThis.Request))throw new TypeError("`input` must be a string, URL, or Request");if(this._options.prefixUrl&&"string"===typeof this._input){
if(this._input.startsWith("/"))throw new Error("`input` must not begin with a slash when using `prefixUrl`");if(!this._options.prefixUrl.endsWith("/"))this._options.prefixUrl+="/";this._input=this._options.prefixUrl+this._input}
if(supportsAbortController){this.abortController=new globalThis.AbortController;if(this._options.signal){const originalSignal=this._options.signal;this._options.signal.addEventListener("abort",(()=>{
this.abortController.abort(originalSignal.reason)}))}this._options.signal=this.abortController.signal}if(supportsRequestStreams)this._options.duplex="half";this.request=new globalThis.Request(this._input,this._options)
;if(this._options.searchParams){const textSearchParams="string"===typeof this._options.searchParams?this._options.searchParams.replace(/^\?/,""):new URLSearchParams(this._options.searchParams).toString()
;const searchParams="?"+textSearchParams;const url=this.request.url.replace(/(?:\?.*?)?(?=#|$)/,searchParams)
;if((supportsFormData&&this._options.body instanceof globalThis.FormData||this._options.body instanceof URLSearchParams)&&!(this._options.headers&&this._options.headers["content-type"]))this.request.headers.delete("content-type")
;this.request=new globalThis.Request(new globalThis.Request(url,{...this.request}),this._options)}if(void 0!==this._options.json){this._options.body=JSON.stringify(this._options.json)
;this.request.headers.set("content-type",this._options.headers.get("content-type")??"application/json");this.request=new globalThis.Request(this.request,{body:this._options.body})}}}
/*! MIT License © Sindre Sorhus */
const createInstance=defaults=>{const ky=(input,options)=>Ky.create(input,validateAndMerge(defaults,options));for(const method of requestMethods)ky[method]=(input,options)=>Ky.create(input,validateAndMerge(defaults,options,{method:method}))
;ky.create=newDefaults=>createInstance(validateAndMerge(newDefaults));ky.extend=newDefaults=>createInstance(validateAndMerge(defaults,newDefaults));ky.stop=stop;return ky};const ky=createInstance();const distribution=ky
;var dist=__webpack_require__(689);var add_items_to_cart_payload=__webpack_require__(438);const OptionsWithValues=(0,dist.type)({name:(0,dist.string)(),value:(0,dist.string)()});const ItemAddedToCart=(0,dist.type)({id:(0,dist.number)(),
properties:(0,dist.nullable)((0,dist.optional)((0,dist.record)((0,dist.string)(),(0,dist.unknown)()))),quantity:(0,dist.number)(),variant_id:(0,dist.number)(),key:(0,dist.string)(),title:(0,dist.nullable)((0,dist.string)()),price:(0,
dist.number)(),original_price:(0,dist.number)(),discounted_price:(0,dist.number)(),line_price:(0,dist.number)(),original_line_price:(0,dist.number)(),total_discount:(0,dist.number)(),discounts:(0,dist.array)((0,dist.unknown)()),sku:(0,
dist.nullable)((0,dist.optional)((0,dist.string)())),grams:(0,dist.number)(),vendor:(0,dist.nullable)((0,dist.optional)((0,dist.string)())),taxable:(0,dist.nullable)((0,dist.boolean)()),product_id:(0,dist.nullable)((0,dist.optional)((0,
dist.number)())),product_has_only_default_variant:(0,dist.nullable)((0,dist.optional)((0,dist.boolean)())),gift_card:(0,dist.boolean)(),final_price:(0,dist.number)(),final_line_price:(0,dist.number)(),url:(0,dist.string)(),
featured_image:(0,dist.nullable)((0,dist.type)({alt:(0,dist.nullable)((0,dist.string)()),height:(0,dist.nullable)((0,dist.number)()),url:(0,dist.nullable)((0,dist.string)()),width:(0,dist.nullable)((0,dist.number)())})),handle:(0,
dist.nullable)((0,dist.optional)((0,dist.string)())),requires_shipping:(0,dist.nullable)((0,dist.boolean)()),product_type:(0,dist.nullable)((0,dist.optional)((0,dist.string)())),product_title:(0,dist.nullable)((0,dist.optional)((0,
dist.string)())),product_description:(0,dist.nullable)((0,dist.optional)((0,dist.string)())),variant_title:(0,dist.nullable)((0,dist.string)()),variant_options:(0,dist.nullable)((0,dist.array)((0,dist.string)())),options_with_values:(0,
dist.nullable)((0,dist.array)(OptionsWithValues)),line_level_discount_allocations:(0,dist.array)((0,dist.unknown)()),line_level_total_discount:(0,dist.number)()});const ItemsAddedToCart=(0,dist.type)({items:(0,dist.array)(ItemAddedToCart)})
;const makeAddItemsToCart=function(agent){return async function addItemsToCart(rawPayload){try{const payload=(0,dist.create)(rawPayload,add_items_to_cart_payload.Payload);return await agent.post("/cart/add.js",{json:payload}).json()
}catch(err){if(err instanceof dist.StructError){console.error(err,{payload:rawPayload});throw new Error("Internal validation error")}if(err instanceof HTTPError){const details=await err.response.json();console.warn(details,{
payload:rawPayload});throw new Error(details.description||details.message||"Cart Error")}throw new Error("Internal error")}}};const PayloadItem=(0,dist.type)({lineItemKey:(0,dist.size)((0,dist.string)(),10,1/0),quantity:(0,dist.min)((0,
dist.number)(),0)});const Payload=(0,dist.type)({items:(0,dist.size)((0,dist.array)(PayloadItem),1,1/0)});const makeChangeItemQuantity=function(agent){return async function changeItemQuantity(rawPayload){const{items:items}=(0,
dist.create)(rawPayload,Payload);const updates=items.reduce(((acc,param)=>{let{lineItemKey:id,quantity:quantity}=param;acc[id]=quantity;return acc}),{});await agent.post("/cart/update.js",{json:{updates:updates}}).json()}}
;const makeFetchCartContents=function(agent){return async function fetchCartContents(){return await agent.get("/cart.json").json()}};const update_cart_note_Payload=(0,dist.type)({note:(0,dist.string)()})
;const makeUpdateCartNote=function(agent){return async function updateCartNote(rawPayload){const{note:note}=(0,dist.create)(rawPayload,update_cart_note_Payload);await agent.post("/cart/update.js",{json:{note:note}}).json()}}
;const CartAttributeName=(0,dist.size)((0,dist.string)(),1,256);const CartAttribute=(0,dist.tuple)([CartAttributeName,(0,dist.string)()]);const update_cart_attributes_Payload=(0,dist.array)(CartAttribute)
;const makeUpdateCartAttributes=function(agent){return async function updateCartAttributes(rawPayload){const attrEntries=update_cart_attributes_Payload.create(rawPayload);const attributes=attrEntries.reduce((function(acc,param){
let[key,value]=param;acc[key]=value;return acc}),{});await agent.post("/cart/update.js",{json:{attributes:attributes}}).json()}};const agent=distribution.create({retry:{limit:3,methods:["get"]},hooks:{beforeError:[async err=>{
const{response:response}=err;try{console.warn("Cart API error",response.status,response.body,response.type)}catch(_err){console.error("Cart error response cannot be processed",_err,response)}return err}]}});const Context={
addItemsToCart:makeAddItemsToCart(agent),changeItemQuantity:makeChangeItemQuantity(agent),fetchCartContents:makeFetchCartContents(agent),updateCartAttributes:makeUpdateCartAttributes(agent),updateCartNote:makeUpdateCartNote(agent)}
;const call=(func,payload)=>({__type:"call",func:func,args:[payload]});const CartItemDiscount=(0,dist.unknown)();const CartItemFeaturedImage=(0,dist.type)({url:(0,dist.nullable)((0,dist.string)()),alt:(0,dist.nullable)((0,dist.string)()),
width:(0,dist.nullable)((0,dist.number)()),height:(0,dist.nullable)((0,dist.number)()),aspect_ratio:(0,dist.nullable)((0,dist.number)())});const CartItemProperties=(0,dist.record)((0,dist.string)(),(0,dist.nullable)((0,dist.union)([(0,
dist.boolean)(),(0,dist.number)(),(0,dist.string)(),(0,dist.array)((0,dist.optional)((0,dist.nullable)((0,dist.union)([(0,dist.boolean)(),(0,dist.number)(),(0,dist.string)()]))))])));const OptionWithValue=(0,dist.type)({name:(0,
dist.string)(),value:(0,dist.string)()});const LineLevelDiscountAllocation=(0,dist.unknown)();const CartItem=(0,dist.type)({key:(0,dist.string)(),id:(0,dist.number)(),properties:(0,dist.nullable)(CartItemProperties),quantity:(0,
dist.number)(),variant_id:(0,dist.number)(),title:(0,dist.nullable)((0,dist.string)()),price:(0,dist.number)(),original_price:(0,dist.number)(),discounted_price:(0,dist.number)(),line_price:(0,dist.number)(),original_line_price:(0,
dist.number)(),total_discount:(0,dist.number)(),discounts:(0,dist.array)(CartItemDiscount),sku:(0,dist.nullable)((0,dist.string)()),grams:(0,dist.number)(),vendor:(0,dist.nullable)((0,dist.string)()),taxable:(0,dist.nullable)((0,
dist.boolean)()),product_id:(0,dist.nullable)((0,dist.number)()),product_has_only_default_variant:(0,dist.boolean)(),gift_card:(0,dist.boolean)(),final_price:(0,dist.number)(),final_line_price:(0,dist.number)(),url:(0,dist.string)(),
featured_image:CartItemFeaturedImage,handle:(0,dist.nullable)((0,dist.string)()),requires_shipping:(0,dist.nullable)((0,dist.boolean)()),product_type:(0,dist.nullable)((0,dist.string)()),product_title:(0,dist.nullable)((0,dist.string)()),
product_description:(0,dist.nullable)((0,dist.string)()),variant_title:(0,dist.nullable)((0,dist.string)()),variant_options:(0,dist.nullable)((0,dist.array)((0,dist.string)())),options_with_values:(0,dist.nullable)((0,
dist.array)(OptionWithValue)),line_level_discount_allocations:(0,dist.array)(LineLevelDiscountAllocation),line_level_total_discount:(0,dist.number)()});const CartAttributes=(0,dist.record)((0,dist.string)(),(0,dist.nullable)((0,
dist.union)([(0,dist.number)(),(0,dist.string)()])));const CartLevelDiscountApplication=(0,dist.type)({key:(0,dist.nullable)((0,dist.string)()),title:(0,dist.nullable)((0,dist.string)()),total_allocated_amount:(0,dist.nullable)((0,
dist.number)())});const Cart=(0,dist.type)({token:(0,dist.string)(),note:(0,dist.nullable)((0,dist.string)()),attributes:CartAttributes,original_total_price:(0,dist.number)(),total_price:(0,dist.number)(),total_discount:(0,dist.number)(),
total_weight:(0,dist.number)(),item_count:(0,dist.number)(),items:(0,dist.array)(CartItem),requires_shipping:(0,dist.boolean)(),currency:(0,dist.string)(),items_subtotal_price:(0,dist.number)(),cart_level_discount_applications:(0,
dist.array)(CartLevelDiscountApplication)});const makeAddItems=function(ctx){const{addItemsToCart:addItemsToCart,fetchCartContents:fetchCartContents}=ctx;return function*addItems(machine,payload){try{
const{input:input,resolve:resolve,reject:reject}=payload;if(null==machine.state.contents)throw new Error("Cart contents missing");yield{name:"AddingItems",error:null,contents:machine.state.contents};try{
const rawAddItemsResponse=yield call(addItemsToCart,input);const[err,data]=ItemsAddedToCart.validate(rawAddItemsResponse,{coerce:true})
;if(err instanceof dist.StructError)console.error("Add To Cart response can not be parsed",err.failures(),data);resolve(err?null:null==data?null:data)}catch(err){
reject(err instanceof Error?err:new Error("Unknown error [819a802f80b140d4803315f361ad094b]"))}const rawFetchCartResponse=yield call(fetchCartContents,void 0);const[err,contents]=Cart.validate(rawFetchCartResponse,{coerce:true})
;if(err instanceof dist.StructError){console.error("Cart data can not be parsed",err.failures(),contents);throw err}if(!contents){console.error("Cart data is invalid",contents);throw new Error("Cart data is invalid")}yield{
contents:contents,name:"Stale",error:null};machine.refresh()}catch(err){yield{error:err instanceof Error?err:new Error("Unknown error [f84a567a4b1a4ed093eb219f43e3a6df]"),name:"Failure",contents:machine.state.contents}}}}
;const makeChangeQuantity=function(ctx){const{changeItemQuantity:changeItemQuantity}=ctx;return function*changeQuantity(machine,payload){try{if(null==machine.state.contents)throw new Error("Cart contents missing");yield{name:"Updating",
error:null,contents:machine.state.contents};yield call(changeItemQuantity,payload);yield{name:"Stale",error:null,contents:machine.state.contents};machine.refresh()}catch(err){yield{
error:err instanceof Error?err:new Error("Unknown error [0fb514aefab3448e8d13bef5134ad7ce]"),name:"Failure",contents:machine.state.contents}}}};const makeInit=function(ctx){const{fetchCartContents:fetchCartContents}=ctx
;return function*init(machine){try{yield{name:"Initializing",contents:null,error:null};const rawFetchCartResponse=yield call(fetchCartContents,void 0);const[err,contents]=Cart.validate(rawFetchCartResponse,{coerce:true})
;if(err instanceof dist.StructError){console.error("Cart data can not be parsed",err.failures(),contents);throw err}if(!contents){console.error("Cart data is invalid",contents);throw new Error("Cart data is invalid")}yield{
contents:contents,name:"Ready",error:null}}catch(err){yield{error:err instanceof Error?err:new Error("Unknown error [78218467b35c404ab53c58868518bbdf]"),name:"Failure",contents:machine.state.contents}}}};const makeRemoveItems=function(ctx){
const{changeItemQuantity:changeItemQuantity}=ctx;return function*removeItems(machine,payload){try{const{lineItemKeys:lineItemKeys}=payload;if(null==machine.state.contents)throw new Error("Cart contents missing");yield{name:"Updating",
error:null,contents:machine.state.contents};yield call(changeItemQuantity,{items:lineItemKeys.map((lineItemKey=>({lineItemKey:lineItemKey,quantity:0})))});yield{name:"Stale",error:null,contents:machine.state.contents};machine.refresh()
}catch(err){yield{error:err instanceof Error?err:new Error("Unknown error [cdc8419e654547b5a21307e0ef1b0b67]"),name:"Failure",contents:machine.state.contents}}}};const makeUpdateNote=function(ctx){const{updateCartNote:updateCartNote}=ctx
;return function*updateNote(machine,payload){try{if(null==machine.state.contents)throw new Error("Cart contents missing");yield{name:"Updating",error:null,contents:machine.state.contents};try{yield call(updateCartNote,payload)}catch(err){
console.error("Cart note update failed",err)}yield{name:"Stale",error:null,contents:machine.state.contents};machine.refresh()}catch(err){yield{error:err instanceof Error?err:new Error("Unknown error [e9a6faf592024eae8f9dae864776906e]"),
name:"Failure",contents:machine.state.contents}}}};const makeRefresh=function(ctx){const{fetchCartContents:fetchCartContents}=ctx;return function*refresh(machine){try{if(null==machine.state.contents)throw new Error("Cart contents missing")
;yield{name:"Refreshing",error:null,contents:machine.state.contents};const firstPass=yield call(fetchCartContents,void 0);const contents=Cart.create(firstPass);yield{contents:contents,name:"Ready",error:null}}catch(err){yield{
error:err instanceof Error?err:new Error("Unknown error [e9022a2fa11a4051b7b1b4141132a0d8]"),name:"Failure",contents:machine.state.contents}}}};const reload=function(){window.location.reload()}
;const{addItemsToCart:addItemsToCart,changeItemQuantity:changeItemQuantity,fetchCartContents:fetchCartContents,updateCartNote:updateCartNote}=Context;const ActionHandler={reload:reload,refresh:makeRefresh({
fetchCartContents:fetchCartContents}),addItems:makeAddItems({addItemsToCart:addItemsToCart,fetchCartContents:fetchCartContents}),changeQuantity:makeChangeQuantity({changeItemQuantity:changeItemQuantity}),init:makeInit({
fetchCartContents:fetchCartContents}),removeItems:makeRemoveItems({changeItemQuantity:changeItemQuantity}),updateNote:makeUpdateNote({updateCartNote:updateCartNote})};const initialState={name:"Idle",contents:null,error:null}
;const makeConfig=function(){let state=arguments.length>0&&void 0!==arguments[0]?arguments[0]:initialState,actions=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ActionHandler
;const{addItems:addItems,changeQuantity:changeQuantity,init:init,refresh:refresh,reload:reload,removeItems:removeItems,updateNote:updateNote}=actions;return{state:state,transitions:{Failure:{reload:reload},Idle:{init:init},Initializing:{
reload:reload},Ready:{addItems:addItems,changeQuantity:changeQuantity,refresh:refresh,reload:reload,removeItems:removeItems,updateNote:updateNote},Refreshing:{reload:reload},Stale:{refresh:refresh,reload:reload},AddingItems:{reload:reload},
Updating:{reload:reload}}}};const createCartMachine=function(){const machineName=`cart_${Date.now()}`;return lib.Machine.create(machineName,makeConfig())};let _machine=null;const getCartMachine=function(){
if(null==_machine)_machine=createCartMachine();return _machine}},438:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Payload:()=>Payload,SingleItemPayload:()=>SingleItemPayload
});var dist=__webpack_require__(689);const Integer=(0,dist.coerce)((0,dist.integer)(),(0,dist.string)(),(function(value){return parseInt(value,10)}));const SingleItemPayload=(0,dist.type)({id:Integer,quantity:Integer,properties:(0,
dist.optional)((0,dist.record)((0,dist.string)(),(0,dist.unknown)())),selling_plan:(0,dist.optional)(Integer)});const Payload=(0,dist.type)({items:(0,dist.size)((0,dist.array)(SingleItemPayload),1,1/0)})}}]);