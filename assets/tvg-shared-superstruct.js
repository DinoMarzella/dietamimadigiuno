"use strict";(self["webpackChunktvg_shopify_theme"]=self["webpackChunktvg_shopify_theme"]||[]).push([[421],{689:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{
StructError:()=>StructError,array:()=>array,boolean:()=>boolean,coerce:()=>coerce,create:()=>create,integer:()=>integer,literal:()=>literal,min:()=>min,nullable:()=>nullable,number:()=>number,optional:()=>optional,record:()=>record,
size:()=>size,string:()=>string,tuple:()=>tuple,type:()=>type,union:()=>union,unknown:()=>unknown});class StructError extends TypeError{constructor(failure,failures){let cached;const{message:message,explanation:explanation,...rest}=failure
;const{path:path}=failure;const msg=0===path.length?message:`At path: ${path.join(".")} -- ${message}`;super(explanation??msg);if(null!=explanation)this.cause=msg;Object.assign(this,rest);this.name=this.constructor.name
;this.failures=()=>cached??(cached=[failure,...failures()])}}function isIterable(x){return isObject(x)&&"function"===typeof x[Symbol.iterator]}function isObject(x){return"object"===typeof x&&null!=x}function isPlainObject(x){
if("[object Object]"!==Object.prototype.toString.call(x))return false;const prototype=Object.getPrototypeOf(x);return null===prototype||prototype===Object.prototype}function print(value){if("symbol"===typeof value)return value.toString()
;return"string"===typeof value?JSON.stringify(value):`${value}`}function shiftIterator(input){const{done:done,value:value}=input.next();return done?void 0:value}function toFailure(result,context,struct,value){
if(true===result)return;else if(false===result)result={};else if("string"===typeof result)result={message:result};const{path:path,branch:branch}=context;const{type:type}=struct
;const{refinement:refinement,message:message=`Expected a value of type \`${type}\`${refinement?` with refinement \`${refinement}\``:""}, but received: \`${print(value)}\``}=result;return{value:value,type:type,refinement:refinement,
key:path[path.length-1],path:path,branch:branch,...result,message:message}}function*toFailures(result,context,struct,value){if(!isIterable(result))result=[result];for(const r of result){const failure=toFailure(r,context,struct,value)
;if(failure)yield failure}}function*run(value,struct,options={}){const{path:path=[],branch:branch=[value],coerce:coerce=false,mask:mask=false}=options;const ctx={path:path,branch:branch};if(coerce){value=struct.coercer(value,ctx)
;if(mask&&"type"!==struct.type&&isObject(struct.schema)&&isObject(value)&&!Array.isArray(value))for(const key in value)if(void 0===struct.schema[key])delete value[key]}let status="valid";for(const failure of struct.validator(value,ctx)){
failure.explanation=options.message;status="not_valid";yield[failure,void 0]}for(let[k,v,s]of struct.entries(value,ctx)){const ts=run(v,s,{path:void 0===k?path:[...path,k],branch:void 0===k?branch:[...branch,v],coerce:coerce,mask:mask,
message:options.message});for(const t of ts)if(t[0]){status=null!=t[0].refinement?"not_refined":"not_valid";yield[t[0],void 0]}else if(coerce){v=t[1]
;if(void 0===k)value=v;else if(value instanceof Map)value.set(k,v);else if(value instanceof Set)value.add(v);else if(isObject(value))if(void 0!==v||k in value)value[k]=v}}
if("not_valid"!==status)for(const failure of struct.refiner(value,ctx)){failure.explanation=options.message;status="not_refined";yield[failure,void 0]}if("valid"===status)yield[void 0,value]}class Struct{constructor(props){
const{type:type,schema:schema,validator:validator,refiner:refiner,coercer:coercer=(value=>value),entries:entries=function*(){}}=props;this.type=type;this.schema=schema;this.entries=entries;this.coercer=coercer
;if(validator)this.validator=(value,context)=>{const result=validator(value,context);return toFailures(result,context,this,value)};else this.validator=()=>[];if(refiner)this.refiner=(value,context)=>{const result=refiner(value,context)
;return toFailures(result,context,this,value)};else this.refiner=()=>[]}assert(value,message){return assert(value,this,message)}create(value,message){return create(value,this,message)}is(value){return is(value,this)}mask(value,message){
return mask(value,this,message)}validate(value,options={}){return validate(value,this,options)}}function assert(value,struct,message){const result=validate(value,struct,{message:message});if(result[0])throw result[0]}
function create(value,struct,message){const result=validate(value,struct,{coerce:true,message:message});if(result[0])throw result[0];else return result[1]}function mask(value,struct,message){const result=validate(value,struct,{coerce:true,
mask:true,message:message});if(result[0])throw result[0];else return result[1]}function is(value,struct){const result=validate(value,struct);return!result[0]}function validate(value,struct,options={}){const tuples=run(value,struct,options)
;const tuple=shiftIterator(tuples);if(tuple[0]){const error=new StructError(tuple[0],(function*(){for(const t of tuples)if(t[0])yield t[0]}));return[error,void 0]}else{const v=tuple[1];return[void 0,v]}}function assign(...Structs){
const isType="type"===Structs[0].type;const schemas=Structs.map((s=>s.schema));const schema=Object.assign({},...schemas);return isType?type(schema):object(schema)}function define(name,validator){return new Struct({type:name,schema:null,
validator:validator})}function deprecated(struct,log){return new Struct({...struct,refiner:(value,ctx)=>void 0===value||struct.refiner(value,ctx),validator(value,ctx){if(void 0===value)return true;else{log(value,ctx)
;return struct.validator(value,ctx)}}})}function dynamic(fn){return new Struct({type:"dynamic",schema:null,*entries(value,ctx){const struct=fn(value,ctx);yield*struct.entries(value,ctx)},validator(value,ctx){const struct=fn(value,ctx)
;return struct.validator(value,ctx)},coercer(value,ctx){const struct=fn(value,ctx);return struct.coercer(value,ctx)},refiner(value,ctx){const struct=fn(value,ctx);return struct.refiner(value,ctx)}})}function lazy(fn){let struct
;return new Struct({type:"lazy",schema:null,*entries(value,ctx){struct??(struct=fn());yield*struct.entries(value,ctx)},validator(value,ctx){struct??(struct=fn());return struct.validator(value,ctx)},coercer(value,ctx){struct??(struct=fn())
;return struct.coercer(value,ctx)},refiner(value,ctx){struct??(struct=fn());return struct.refiner(value,ctx)}})}function omit(struct,keys){const{schema:schema}=struct;const subschema={...schema};for(const key of keys)delete subschema[key]
;switch(struct.type){case"type":return type(subschema);default:return object(subschema)}}function partial(struct){const schema=struct instanceof Struct?{...struct.schema}:{...struct};for(const key in schema)schema[key]=optional(schema[key])
;return object(schema)}function pick(struct,keys){const{schema:schema}=struct;const subschema={};for(const key of keys)subschema[key]=schema[key];return object(subschema)}function struct(name,validator){
console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`.");return define(name,validator)}function any(){return define("any",(()=>true))}function array(Element){return new Struct({type:"array",schema:Element,
*entries(value){if(Element&&Array.isArray(value))for(const[i,v]of value.entries())yield[i,v,Element]},coercer(value){return Array.isArray(value)?value.slice():value},validator(value){
return Array.isArray(value)||`Expected an array value, but received: ${print(value)}`}})}function bigint(){return define("bigint",(value=>"bigint"===typeof value))}function boolean(){
return define("boolean",(value=>"boolean"===typeof value))}function date(){return define("date",(value=>value instanceof Date&&!isNaN(value.getTime())||`Expected a valid \`Date\` object, but received: ${print(value)}`))}
function enums(values){const schema={};const description=values.map((v=>print(v))).join();for(const key of values)schema[key]=key;return new Struct({type:"enums",schema:schema,validator(value){
return values.includes(value)||`Expected one of \`${description}\`, but received: ${print(value)}`}})}function func(){return define("func",(value=>"function"===typeof value||`Expected a function, but received: ${print(value)}`))}
function instance(Class){return define("instance",(value=>value instanceof Class||`Expected a \`${Class.name}\` instance, but received: ${print(value)}`))}function integer(){
return define("integer",(value=>"number"===typeof value&&!isNaN(value)&&Number.isInteger(value)||`Expected an integer, but received: ${print(value)}`))}function intersection(Structs){return new Struct({type:"intersection",schema:null,
*entries(value,ctx){for(const S of Structs)yield*S.entries(value,ctx)},*validator(value,ctx){for(const S of Structs)yield*S.validator(value,ctx)},*refiner(value,ctx){for(const S of Structs)yield*S.refiner(value,ctx)}})}
function literal(constant){const description=print(constant);const t=typeof constant;return new Struct({type:"literal",schema:"string"===t||"number"===t||"boolean"===t?constant:null,validator(value){
return value===constant||`Expected the literal \`${description}\`, but received: ${print(value)}`}})}function map(Key,Value){return new Struct({type:"map",schema:null,*entries(value){
if(Key&&Value&&value instanceof Map)for(const[k,v]of value.entries()){yield[k,k,Key];yield[k,v,Value]}},coercer(value){return value instanceof Map?new Map(value):value},validator(value){
return value instanceof Map||`Expected a \`Map\` object, but received: ${print(value)}`}})}function never(){return define("never",(()=>false))}function nullable(struct){return new Struct({...struct,
validator:(value,ctx)=>null===value||struct.validator(value,ctx),refiner:(value,ctx)=>null===value||struct.refiner(value,ctx)})}function number(){
return define("number",(value=>"number"===typeof value&&!isNaN(value)||`Expected a number, but received: ${print(value)}`))}function object(schema){const knowns=schema?Object.keys(schema):[];const Never=never();return new Struct({
type:"object",schema:schema?schema:null,*entries(value){if(schema&&isObject(value)){const unknowns=new Set(Object.keys(value));for(const key of knowns){unknowns.delete(key);yield[key,value[key],schema[key]]}
for(const key of unknowns)yield[key,value[key],Never]}},validator(value){return isObject(value)||`Expected an object, but received: ${print(value)}`},coercer(value){return isObject(value)?{...value}:value}})}function optional(struct){
return new Struct({...struct,validator:(value,ctx)=>void 0===value||struct.validator(value,ctx),refiner:(value,ctx)=>void 0===value||struct.refiner(value,ctx)})}function record(Key,Value){return new Struct({type:"record",schema:null,
*entries(value){if(isObject(value))for(const k in value){const v=value[k];yield[k,k,Key];yield[k,v,Value]}},validator(value){return isObject(value)||`Expected an object, but received: ${print(value)}`}})}function regexp(){
return define("regexp",(value=>value instanceof RegExp))}function set(Element){return new Struct({type:"set",schema:null,*entries(value){if(Element&&value instanceof Set)for(const v of value)yield[v,v,Element]},coercer(value){
return value instanceof Set?new Set(value):value},validator(value){return value instanceof Set||`Expected a \`Set\` object, but received: ${print(value)}`}})}function string(){
return define("string",(value=>"string"===typeof value||`Expected a string, but received: ${print(value)}`))}function tuple(Structs){const Never=never();return new Struct({type:"tuple",schema:null,*entries(value){if(Array.isArray(value)){
const length=Math.max(Structs.length,value.length);for(let i=0;i<length;i++)yield[i,value[i],Structs[i]||Never]}},validator(value){return Array.isArray(value)||`Expected an array, but received: ${print(value)}`}})}function type(schema){
const keys=Object.keys(schema);return new Struct({type:"type",schema:schema,*entries(value){if(isObject(value))for(const k of keys)yield[k,value[k],schema[k]]},validator(value){
return isObject(value)||`Expected an object, but received: ${print(value)}`},coercer(value){return isObject(value)?{...value}:value}})}function union(Structs){const description=Structs.map((s=>s.type)).join(" | ");return new Struct({
type:"union",schema:null,coercer(value){for(const S of Structs){const[error,coerced]=S.validate(value,{coerce:true});if(!error)return coerced}return value},validator(value,ctx){const failures=[];for(const S of Structs){
const[...tuples]=run(value,S,ctx);const[first]=tuples;if(!first[0])return[];else for(const[failure]of tuples)if(failure)failures.push(failure)}
return[`Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,...failures]}})}function unknown(){return define("unknown",(()=>true))}function coerce(struct,condition,coercer){return new Struct({
...struct,coercer:(value,ctx)=>is(value,condition)?struct.coercer(coercer(value,ctx),ctx):struct.coercer(value,ctx)})}function defaulted(struct,fallback,options={}){return coerce(struct,unknown(),(x=>{
const f="function"===typeof fallback?fallback():fallback;if(void 0===x)return f;if(!options.strict&&isPlainObject(x)&&isPlainObject(f)){const ret={...x};let changed=false;for(const key in f)if(void 0===ret[key]){ret[key]=f[key];changed=true
}if(changed)return ret}return x}))}function trimmed(struct){return coerce(struct,string(),(x=>x.trim()))}function empty(struct){return refine(struct,"empty",(value=>{const size=getSize(value)
;return 0===size||`Expected an empty ${struct.type} but received one with a size of \`${size}\``}))}function getSize(value){if(value instanceof Map||value instanceof Set)return value.size;else return value.length}
function max(struct,threshold,options={}){const{exclusive:exclusive}=options
;return refine(struct,"max",(value=>exclusive?value<threshold:value<=threshold||`Expected a ${struct.type} less than ${exclusive?"":"or equal to "}${threshold} but received \`${value}\``))}function min(struct,threshold,options={}){
const{exclusive:exclusive}=options;return refine(struct,"min",(value=>exclusive?value>threshold:value>=threshold||`Expected a ${struct.type} greater than ${exclusive?"":"or equal to "}${threshold} but received \`${value}\``))}
function nonempty(struct){return refine(struct,"nonempty",(value=>{const size=getSize(value);return size>0||`Expected a nonempty ${struct.type} but received an empty one`}))}function pattern(struct,regexp){
return refine(struct,"pattern",(value=>regexp.test(value)||`Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`))}function size(struct,min,max=min){const expected=`Expected a ${struct.type}`
;const of=min===max?`of \`${min}\``:`between \`${min}\` and \`${max}\``;return refine(struct,"size",(value=>{
if("number"===typeof value||value instanceof Date)return min<=value&&value<=max||`${expected} ${of} but received \`${value}\``;else if(value instanceof Map||value instanceof Set){const{size:size}=value
;return min<=size&&size<=max||`${expected} with a size ${of} but received one with a size of \`${size}\``}else{const{length:length}=value
;return min<=length&&length<=max||`${expected} with a length ${of} but received one with a length of \`${length}\``}}))}function refine(struct,name,refiner){return new Struct({...struct,*refiner(value,ctx){yield*struct.refiner(value,ctx)
;const result=refiner(value,ctx);const failures=toFailures(result,ctx,struct,value);for(const failure of failures)yield{...failure,refinement:name}}})}}}]);